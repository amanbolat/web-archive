<!DOCTYPE html> <html lang=en data-lt-installed=true><!--
 Page saved with SingleFile 
 url: https://borretti.me/article/composable-sql 
 saved date: Wed Jan 29 2025 20:51:58 GMT+0100 (Central European Standard Time)
--><meta charset=utf-8>
<meta name=viewport content="width=device-width, initial-scale=1">
<meta http-equiv=X-UA-Compatible content="IE=edge">
<title>Composable SQL</title>
<meta property=og:type content=article>
<meta property=og:url content=https://borretti.me/article/composable-sql>
<meta property=og:title content="Composable SQL">
<meta property=og:description content="Better SQL through typed, composable query fragments.">
<meta property=og:site_name content="Fernando Borretti">
<meta name=author content="Fernando Borretti">
<meta name=description content="Better SQL through typed, composable query fragments.">
<meta name=keywords content>
<meta property=article:published_time content=2025-01-24T00:00:00+00:00>
<link rel=canonical href=https://borretti.me/article/composable-sql>
<meta name=referrer content=no-referrer><link rel=icon href=data:, data-sf-original-href=https://borretti.me/assets/favicon.jpg><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
 <body>
 
<div class=layout-common>
 <nav class=top-nav role=navigation>
 <ul>
 <li>
 <a href=https://borretti.me/>Home</a>
 </li>
 
 <li>
 <span class=sep>❖</span>
 </li>
 <li>
 <a href=https://borretti.me/article/>Articles</a>
 </li>
 
 </ul>
 </nav>
 <main><div class=layout-article>
 <header>
 <h1>Composable SQL</h1>
 </header>
 <article>
 <p>SQL could be improved somewhat by introducing composable query fragments with statically-typed interfaces. I begin by explaining two areas (testing and reusing business logic) where SQL does very poorly. Then I explain my solution, and how it addresses the problems.</p>
<h1 id=contents>Contents</h1>
<ol>
 <li><a href=#motivation>Motivation</a>
 <ol>
 <li><a href=#testing>Testing</a></li>
 <li><a href=#logic>Business Logic</a>
 <ol>
 <li><a href=#dup>Duplication</a></li>
 <li><a href=#denorm>Denormalization</a></li>
 <li><a href=#views>Views</a></li>
 </ol>
 </li>
 </ol>
 </li>
 <li><a href=#sol>The Solution</a>
 <ol>
 <li><a href=#func>Functors</a></li>
 <li><a href=#funtest>Functors for Testing</a></li>
 <li><a href=#funlog>Functors for Business Logic</a></li>
 </ol>
 </li>
 <li><a href=#conclusion>Conclusion</a></li>
 <li><a href=#app>Appendices</a>
 <ol>
 <li><a href=#generics>Apendix: Generics</a></li>
 <li><a href=#general>Appendix: Generalizing Business Logic</a></li>
 <li><a href=#naming>Appendix: Naming</a></li>
 <li><a href=#global>Appendix: Global Variables</a></li>
 </ol>
 </li>
</ol>
<h1 id=motivation>Motivation</h1>
<p>This section explains two big pain points of SQL.</p>
<h2 id=testing>Testing</h2>
<p>Testing SQL is impossible. Consider the simplest possible query:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>select</span> <span class=n>title</span> <span class=k>from</span> <span class=n>books</span><span class=p>;</span>
</code></pre></div></div>
<p>What does this query depend on? It depends on the <code class="language-plaintext highlighter-rouge">title</code> column from the <code class="language-plaintext highlighter-rouge">books</code> table. In an ideal world, the smallest complete test dataset for this query would be:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>insert</span> <span class=k>into</span> <span class=n>books</span> <span class=p>(</span><span class=n>title</span><span class=p>)</span> <span class=k>values</span> <span class=p>(</span><span class=s1>'The King in Yellow'</span><span class=p>);</span>
</code></pre></div></div>
<p>But it’s not enough to populate the columns a query depends on. You have to populate <em>every column</em> in the row:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>insert</span> <span class=k>into</span> <span class=n>books</span> <span class=p>(</span><span class=n>book_id</span><span class=p>,</span> <span class=n>author_id</span><span class=p>,</span> <span class=n>title</span><span class=p>,</span> <span class=n>isbn</span><span class=p>,</span> <span class=nb>year</span><span class=p>,</span> <span class=k>language</span><span class=p>,</span> <span class=p>...</span>
</code></pre></div></div>
<p>The values of these columns are <em>completely causally disconnected</em> from the query. They cannot influence the output. But you must populate them.</p>
<p>And the process is explosive: to insert a row you have to insert every row that it points to, on and on recursively until you hit a root object (typically a user). And each of those rows must have <em>every one</em> of its columns populated.</p>
<p>Testing the simplest query requires building up a massive object graph, just to test an infinitesimal slice of it. Reams and reams of code have to be written to insert test data, of which only a few lines are causally relevant. More of your time will be spent writing test fixtures, factories, test helpers. Tests become too long to write <em>ab initio</em>, so a test suite becomes a giant file of copy-pasted functions, each of which differ in only a few lines.</p>
<p>Shallow queries that retrieve objects near the root of the foreign key DAG are easy to test. Queries that involve joins across many tables, or which retrieve objects that are deep in the DAG, are catastrophically expensive to write tests for. So your test coverage is uneven: the queries that don’t need tests have them, the queries that need them don’t.</p>
<p>And the performance of the test suite is really bad, which starts to hurt even in medium-sized projects.</p>
<p>There are no good solutions to this:</p>
<ul>
 <li>You can make every single FK in the database deferred, so it’s checked at the end of a transaction rather than during an insert, but that solves half the problem (the non-null columns still need to be populated) and requires updating every FK in the schema.</li>
 <li>You can make all your columns nullable, ruining the data model.</li>
 <li>You can write all your tables in sixth normal form, which is the same as making everything nullable.</li>
</ul>
<h2 id=logic>Business Logic</h2>
<p>“Business logic” is usually thought of as imperative: in response to an event, we do X, Y, and Z. But if you have a fully-normalized database, a lot of your business logic is going to be implemented at read-time. This generally falls into two categories:</p>
<ul>
 <li>The state of an object is determined dynamically from the state of its constituents, e.g. your score on an exam is the sum of the questions you got right.</li>
 <li>Reporting features that require OLAP queries specifically, and which query properties of the data which are computed dynamically.</li>
</ul>
<p>Imagine you’re working on a logistics system. We have boxes, which have mass, and boxes can go on pallets:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=k>table</span> <span class=n>boxes</span> <span class=p>(</span>
    <span class=n>box_id</span> <span class=n>uuid</span> <span class=k>primary</span> <span class=k>key</span><span class=p>,</span>
    <span class=n>mass</span> <span class=nb>decimal</span> <span class=k>not</span> <span class=k>null</span><span class=p>,</span>
    <span class=n>pallet_id</span> <span class=n>uuid</span> <span class=k>not</span> <span class=k>null</span> <span class=k>references</span> <span class=n>pallets</span><span class=p>(</span><span class=n>pallet_id</span><span class=p>)</span>
<span class=p>);</span>
</code></pre></div></div>
<p>Pallets have a dry mass, a maximum payload mass they can support, and they go on containers:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=k>table</span> <span class=n>pallets</span> <span class=p>(</span>
    <span class=n>pallet_id</span> <span class=n>uuid</span> <span class=k>primary</span> <span class=k>key</span><span class=p>,</span>
    <span class=n>dry_mass</span> <span class=nb>decimal</span> <span class=k>not</span> <span class=k>null</span><span class=p>,</span>
    <span class=n>max_payload_mass</span> <span class=nb>decimal</span> <span class=k>not</span> <span class=k>null</span><span class=p>,</span>
    <span class=n>container_id</span> <span class=n>uuid</span> <span class=k>not</span> <span class=k>null</span> <span class=k>references</span> <span class=n>containers</span><span class=p>(</span><span class=n>container_id</span><span class=p>)</span>
<span class=p>);</span>
</code></pre></div></div>
<p>Pallets also have a number of computed properties:</p>
<ol>
 <li>Payload mass: the sum of the masses of all the boxes on the pallet.</li>
 <li>Clearance: if the pallet’s payload mass is less than the maximum, the pallet is cleared to be moved.</li>
 <li>Wet mass: the sum of the dry mass and the payload mass.</li>
</ol>
<p>Containers are analogous to pallets, but one level up:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=k>table</span> <span class=n>containers</span> <span class=p>(</span>
    <span class=n>container_id</span> <span class=n>uuid</span> <span class=k>primary</span> <span class=k>key</span><span class=p>,</span>
    <span class=n>dry_mass</span> <span class=nb>decimal</span> <span class=k>not</span> <span class=k>null</span><span class=p>,</span>
    <span class=n>max_payload_mass</span> <span class=nb>decimal</span> <span class=k>not</span> <span class=k>null</span>
<span class=p>);</span>
</code></pre></div></div>
<p>With just three tables, there are many possible questions we could ask about our data:</p>
<ol>
 <li>Is this container cleared to load?</li>
 <li>How much does this container mass?</li>
 <li>What’s the total mass of this set of containers (e.g., those being loaded onto a ship)?</li>
 <li>Are we packing boxes efficiently? What’s the average percent utilization on our pallets?</li>
 <li>Which pallet should this box be packed into?</li>
 <li>Are any pallets in this container in excess of their maximum payload mass?</li>
</ol>
<p>Each question corresponds to a different query. Each query depends on computed properties of the data, such as the clearance state of a container. On top of that, logic builds on logic: the logic for “is this pallet cleared?” depends on the logic for “what is the payload mass of this pallet?”.</p>
<p>We want to write our queries in a way that satisfies these properties:</p>
<ol>
 <li>Performance: queries should be fast.</li>
 <li>Testability: queries should be testable.</li>
 <li>Comprehensibility: queries should be readable and understandable through local reasoning.</li>
 <li>Reusability: logic should be defined once, tested once, and used in many places.</li>
</ol>
<p>Because SQL has such limited means of abstraction, we have only a choice of bad options:</p>
<ol>
 <li>We can duplicate the business logic across queries, or</li>
 <li>We can give up on normalization and cache the computed properties in response to events, or</li>
 <li>We can implement the business logic in views.</li>
</ol>
<p>The next sections explain why each option is bad.</p>
<h3 id=dup>Duplication</h3>
<p>Write out the logic for computed properties in every query. Hope that changes to the business logic affect every place where the logic is defined. Testing would help here, but as discussed above, testing (especially for deep OLAP-type queries) is intractable because of the combinatorial explosion.</p>
<p>Worse, if you duplicate the logic, but tailor it to the specifics of the query, it becomes much harder to actually find other instances. There is a single, abstract concept of a relation that e.g. maps pallet IDs to payload masses sale counts, but the implementations are varied and can’t easily be identified.</p>
<p>While the logic here isn’t too complex, there are enough degrees of freedom that, if the logic is duplicated, we will have drift.</p>
<p>Ideally, the logic for the definition of “how heavy is this pallet?” and “is this container ready to be loaded?” should be defined once, and tested once, but used in many places.</p>
<h3 id=denorm>Denormalization</h3>
<p>We can denormalize the computed properties: adding a <code class="language-plaintext highlighter-rouge">payload_mass</code> and <code class="language-plaintext highlighter-rouge">cleared</code> column to both the <code class="language-plaintext highlighter-rouge">pallets</code> and <code class="language-plaintext highlighter-rouge">containers</code> tables. Whenever an event enters the system which affects these properties, they are recomputed. The logic can be implemented in one place, at the application layer (where it is easier to test).</p>
<p>The costs of denormalization are well-known, but it boils down to:</p>
<ul>
 <li>There are now two definitions of the same concept: the declarative one and the imperative one.</li>
 <li>There is an implicit invariant: for every row in the <code class="language-plaintext highlighter-rouge">pallets</code> table, the value of <code class="language-plaintext highlighter-rouge">payload_mass</code> must equal the result of the declarative query on the normalized data model. Detecting violations of this invariant is both computationally expensive and requires building custom infrastructure.</li>
 <li>When writing a new mutation, you have to very carefully consider all the places in the database where denormalization is happening, to ensure the mutation doesn’t violate implicit invariants.</li>
 <li>Dually, when <em>introducing</em> denormalization, you have to consider all existing mutations to patch the ones that relate to the denormalized data.</li>
 <li>Bugs in the code require identifying all affected data (potentially impossible!) and running a data migration (incredibly tiresome).</li>
 <li>Finally, there is the cost of physical storage. While storage is cheap, IaaS providers love to charge extra for database disks, as if only the finest iron oxides are fit for your Postgres cluster.</li>
</ul>
<p>With denormalization, the individual <em>queries</em> are more testable, but now the system as a whole has to be tested, end to end, to ensure the key invariants are maintained.</p>
<h3 id=views>Views</h3>
<p>This is an approach I experimented with. I call it the “tree of views”. You write a view for each of these read-time properties, and then your queries can read from those views. It’s a tree because views can query other views, since logic builds upon logic (e.g. the logic for how well a product line is selling depends on the logic for how well each product is selling). The result is that each view is a very focused, very atomic piece of business logic, and the top-level queries can read from the views as if they were reading denormalized data, so they are usually very short.</p>
<p>Concretely, for this case, you would write views like this:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>-- Map a pallet ID to its payload mass.</span>
<span class=k>create</span> <span class=k>view</span> <span class=n>pallet_payload_mass</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>,</span>
        <span class=n>coalesce</span><span class=p>(</span><span class=k>sum</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>mass</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=k>as</span> <span class=n>payload_mass</span>
    <span class=k>from</span>
        <span class=n>pallets</span> <span class=n>p</span>
    <span class=k>left</span> <span class=k>outer</span> <span class=k>join</span>
        <span class=n>boxes</span> <span class=n>b</span> <span class=k>on</span> <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=n>b</span><span class=p>.</span><span class=n>pallet_id</span>
    <span class=k>group</span> <span class=k>by</span>
        <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>;</span>

<span class=c1>-- Map a pallet ID to its clearance state.</span>
<span class=k>create</span> <span class=k>view</span> <span class=n>pallet_clearance</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>,</span>
        <span class=p>(</span><span class=n>ppm</span><span class=p>.</span><span class=n>payload_mass</span> <span class=o>&lt;</span> <span class=n>p</span><span class=p>.</span><span class=n>max_payload_mass</span><span class=p>)</span> <span class=k>as</span> <span class=n>cleared</span>
    <span class=k>from</span>
        <span class=n>pallets</span> <span class=n>p</span>
    <span class=k>inner</span> <span class=k>join</span>
        <span class=n>pallet_payload_mass</span> <span class=n>ppm</span> <span class=k>on</span> <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=n>ppm</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>;</span>
</code></pre></div></div>
<p>And so on. With the views having the following data dependencies:</p>
<p><img src=data:, alt="A graph showing the data dependencies between views, rooted at tables." data-sf-original-src=https://borretti.me/assets/content/composable-sql/views.svg></p>
<p>What you hope happens is that Postgres will recursively inline every view, merge them all together into a gigaquery, and shuffle the predicates up and down to maximally optimize the query. That was the conceit. And of course that never happens.</p>
<p>The central problem is that views have to be written for the general case, and then you filter on the view’s output. Views can’t take parameters. And the optimizer is very conservative about pushing predicates down into the view. The <code class="language-plaintext highlighter-rouge">explain analyze</code> output shows these massive sequential scans, where only a tiny fraction of the data is ever needed, meaning Postgres is materializing the view and then filtering on it.</p>
<p>An analogous situation is if you’ve ever written a query with lots of very general CTEs, and with filtering at the end:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>with</span> <span class=n>foo</span> <span class=k>as</span> <span class=p>(</span> <span class=p>...</span> <span class=p>),</span>
     <span class=n>bar</span> <span class=k>as</span> <span class=p>(</span> <span class=p>...</span> <span class=p>),</span>
     <span class=n>baz</span> <span class=k>as</span> <span class=p>(</span> <span class=p>...</span> <span class=p>)</span>
<span class=k>select</span> <span class=n>derp</span> <span class=k>from</span> <span class=n>baz</span> <span class=k>where</span> <span class=p>...;</span>
</code></pre></div></div>
<p>These are often slow. Moving the predicates into the CTEs:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>with</span> <span class=n>foo</span> <span class=k>as</span> <span class=p>(</span> <span class=p>...</span> <span class=k>where</span> <span class=p>...</span> <span class=p>),</span>
     <span class=n>bar</span> <span class=k>as</span> <span class=p>(</span> <span class=p>...</span> <span class=k>where</span> <span class=p>...</span> <span class=p>),</span>
     <span class=n>baz</span> <span class=k>as</span> <span class=p>(</span> <span class=p>...</span> <span class=k>where</span> <span class=p>...</span> <span class=p>)</span>
<span class=k>select</span> <span class=n>derp</span> <span class=k>from</span> <span class=n>baz</span><span class=p>;</span>
</code></pre></div></div>
<p>Improves performance by forcing Postgres to do the filtering at earlier stages. But the fact that Postgres won’t push predicates into the CTEs on its own means CTEs and views are a minefield of pessimization, and there’s a performance upper bound to using them<sup id=fnref:perf role=doc-noteref><a href=#fn:perf class=footnote rel=footnote>1</a></sup>.</p>
<p>If the query planner were <a href=https://wiki.c2.com/?SufficientlySmartCompiler>sufficiently smart</a>, this wouldn’t be a problem. But the sufficiently smart query planner is always just one more heuristic away.</p>
<h1 id=sol>The Solution</h1>
<p>Imagine a programming language without functions. You can only write code that operates on concrete values, i.e. variables or literals. So instead of writing a function and calling it anywhere you have to write these little code templates as comments and every time you want to “call” the “function” you copy the template and do a search/replace.</p>
<p>This would be tiresome. But that’s what SQL is. The concrete values are the table names. The code is the queries. And the function templates you have to search replace are your business logic, which must be inlined everywhere it is used.</p>
<p>This formulation suggests the solution: we need something like functions, for SQL. That is, we need a way to define composable query fragments with statically-typed interfaces. I’m calling these <strong>functors</strong>.</p>
<h2 id=func>Functors</h2>
<p>The parameters to a functor are tables satisfying some interface, the return type is the return type of the body query. For example, this<sup id=fnref:syn role=doc-noteref><a href=#fn:syn class=footnote rel=footnote>2</a></sup>:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=n>functor</span> <span class=n>author_books</span><span class=p>(</span>
    <span class=n>a</span> <span class=k>table</span> <span class=p>(</span><span class=n>author_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>name</span> <span class=nb>text</span><span class=p>),</span>
    <span class=n>b</span> <span class=k>table</span> <span class=p>(</span><span class=n>title</span> <span class=nb>text</span><span class=p>,</span> <span class=n>author_id</span> <span class=n>uuid</span><span class=p>)</span>
<span class=p>)</span> <span class=k>returns</span> <span class=k>table</span> <span class=p>(</span><span class=n>author</span> <span class=nb>text</span><span class=p>,</span> <span class=n>title</span> <span class=nb>text</span><span class=p>)</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=n>a</span><span class=p>.</span><span class=n>name</span> <span class=k>as</span> <span class=n>author</span><span class=p>,</span>
        <span class=n>b</span><span class=p>.</span><span class=n>title</span><span class=p>,</span>
    <span class=k>from</span>
        <span class=n>a</span>
    <span class=k>inner</span> <span class=k>join</span>
        <span class=n>b</span> <span class=k>on</span> <span class=n>b</span><span class=p>.</span><span class=n>author_id</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>author_id</span><span class=p>;</span>
</code></pre></div></div>
<p>Declares a functor <code class="language-plaintext highlighter-rouge">author_books</code>. The parameter <code class="language-plaintext highlighter-rouge">a</code> is any table that has <em>at least</em> a column <code class="language-plaintext highlighter-rouge">author_id</code> of type <code class="language-plaintext highlighter-rouge">uuid</code> and a column <code class="language-plaintext highlighter-rouge">name</code> of type text <sup id=fnref:null role=doc-noteref><a href=#fn:null class=footnote rel=footnote>3</a></sup>. The functor’s return type is the type of the rows returned by the query.</p>
<p>Table types form a <a href=https://en.wikipedia.org/wiki/Subtyping>subtyping</a> relationship, so any table with a <code class="language-plaintext highlighter-rouge">title</code> column of type <code class="language-plaintext highlighter-rouge">text</code> can be passed as an argument. This is the same as to <a href=https://en.wikipedia.org/wiki/Row_polymorphism>row polymorphism</a> in <a href=https://www.typescriptlang.org/docs/handbook/type-compatibility.html>TypeScript</a>.</p>
<h2 id=funtest>Functors for Testing</h2>
<p>The reason testing is hard is SQL queries depend on <em>concrete</em> tables. But functors can depend on <em>interfaces</em> instead.</p>
<p>The business logic for “payload mass of a pallet” is implemented by this query:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=c1>-- Maps a pallet ID to its payload mass.</span>
<span class=k>select</span>
    <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>,</span>
    <span class=n>coalesce</span><span class=p>(</span><span class=k>sum</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>mass</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=k>as</span> <span class=n>payload_mass</span>
<span class=k>from</span>
    <span class=n>pallets</span> <span class=n>p</span>
<span class=k>left</span> <span class=k>outer</span> <span class=k>join</span>
    <span class=n>boxes</span> <span class=n>b</span> <span class=k>on</span> <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=n>b</span><span class=p>.</span><span class=n>pallet_id</span>
<span class=k>group</span> <span class=k>by</span>
    <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>;</span>
</code></pre></div></div>
<p>Can be parameterized like so:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=n>functor</span> <span class=n>pallet_payload_mass</span><span class=p>(</span>
    <span class=n>p</span> <span class=k>table</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>),</span>
    <span class=n>b</span> <span class=k>table</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>mass</span> <span class=nb>decimal</span><span class=p>)</span>
<span class=p>)</span> <span class=k>returns</span> <span class=k>table</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>payload_mass</span> <span class=nb>decimal</span><span class=p>)</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>,</span>
        <span class=n>coalesce</span><span class=p>(</span><span class=k>sum</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>mass</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=k>as</span> <span class=n>payload_mass</span>
    <span class=k>from</span>
        <span class=n>p</span>
    <span class=k>left</span> <span class=k>outer</span> <span class=k>join</span>
        <span class=n>b</span> <span class=k>on</span> <span class=n>b</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span>
    <span class=k>group</span> <span class=k>by</span>
        <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>;</span>
</code></pre></div></div>
<p>We can test this query against fake tables satisfying the interface, e.g.:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=k>table</span> <span class=n>test_boxes</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>mass</span> <span class=nb>decimal</span><span class=p>);</span>
<span class=k>create</span> <span class=k>table</span> <span class=n>test_pallets</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>);</span>

<span class=k>insert</span> <span class=k>into</span> <span class=p>...;</span>

<span class=k>select</span> <span class=n>payload_mass</span> <span class=k>from</span> <span class=n>pallet_payload_mass</span><span class=p>(</span><span class=n>test_pallets</span><span class=p>,</span> <span class=n>test_boxes</span><span class=p>);</span>
</code></pre></div></div>
<p>While <code class="language-plaintext highlighter-rouge">pallets</code> point to <code class="language-plaintext highlighter-rouge">containers</code>, for this test, we don’t need to create a container. We also don’t need to come up with a value <code class="language-plaintext highlighter-rouge">max_payload_pass</code> for the pallet. If a value is causally independent of the query, it doesn’t need to be provided.</p>
<p>Postgres also supports <a href=https://www.postgresql.org/docs/current/queries-values.html>table literals</a>, so there is actually a way to write things without doing a single <code class="language-plaintext highlighter-rouge">insert</code> whatever. Test data can be loaded into a table literal like so:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>with</span> <span class=n>test_boxes</span> <span class=k>as</span> <span class=p>(</span>
    <span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=p>(</span>
        <span class=k>values</span> <span class=p>(</span><span class=s1>'...'</span><span class=p>,</span> <span class=mi>1</span><span class=p>.</span><span class=mi>0</span><span class=p>),</span>
               <span class=p>(</span><span class=s1>'...'</span><span class=p>,</span> <span class=mi>2</span><span class=p>.</span><span class=mi>0</span><span class=p>),</span>
               <span class=p>(</span><span class=s1>'...'</span><span class=p>,</span> <span class=mi>3</span><span class=p>.</span><span class=mi>0</span><span class=p>),</span>
    <span class=p>)</span> <span class=k>as</span> <span class=n>t</span> <span class=p>(</span><span class=n>pallet_id</span><span class=p>,</span> <span class=n>mass</span><span class=p>)</span>
<span class=p>)</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">test_books</code> CTE has type <code class="language-plaintext highlighter-rouge">(title text)</code>, and therefore satisfies the interface.</p>
<h2 id=funlog>Functors for Business Logic</h2>
<p>We have a functor <code class="language-plaintext highlighter-rouge">pallet_payload_mass</code> that maps pallet IDs to their payload mass. The pallet clearance state depends on the pallet’s maximum payload mass, and the pallet’s actual payload mass, so we can implement it as a functor like so:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=n>functor</span> <span class=n>pallet_clearance</span><span class=p>(</span>
    <span class=n>p</span>   <span class=k>table</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>max_payload_mass</span> <span class=nb>decimal</span><span class=p>)</span>
    <span class=n>ppm</span> <span class=k>table</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>payload_mass</span> <span class=nb>decimal</span><span class=p>)</span>
<span class=p>)</span> <span class=k>returns</span> <span class=k>table</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>cleared</span> <span class=nb>boolean</span><span class=p>)</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>,</span>
        <span class=p>(</span><span class=n>ppm</span><span class=p>.</span><span class=n>payload_mass</span> <span class=o>&lt;=</span> <span class=n>p</span><span class=p>.</span><span class=n>max_payload_mass</span><span class=p>)</span> <span class=k>as</span> <span class=n>cleared</span>
    <span class=k>from</span>
        <span class=n>p</span>
    <span class=k>inner</span> <span class=k>join</span>
        <span class=n>ppm</span> <span class=k>on</span> <span class=n>ppm</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>;</span>
</code></pre></div></div>
<p>Even though logic builds on logic, the <code class="language-plaintext highlighter-rouge">pallet_clearance</code> functor doesn’t need to be aware of the <code class="language-plaintext highlighter-rouge">pallet_payload_mass</code> functor. The results of the latter can just be passed in. This makes the functors more testable (since testing one functor won’t call another) but also keeps the interfaces small.</p>
<p>Say we want to query the clearance state of a specific pallet. How do we write this? We can try this:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>select</span>
    <span class=n>pc</span><span class=p>.</span><span class=n>cleared</span>
<span class=k>from</span>
    <span class=n>pallet_clearance</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>pallet_payload_mass</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>boxes</span><span class=p>))</span> <span class=n>pc</span>
<span class=k>where</span>
    <span class=n>pc</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=s1>'...'</span><span class=p>;</span>
</code></pre></div></div>
<p>This query macroexpands into:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>select</span>
    <span class=n>pc</span><span class=p>.</span><span class=n>cleared</span>
<span class=k>from</span>
    <span class=p>(</span>
        <span class=k>select</span>
            <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>,</span>
            <span class=p>(</span><span class=n>ppm</span><span class=p>.</span><span class=n>payload_mass</span> <span class=o>&lt;=</span> <span class=n>p</span><span class=p>.</span><span class=n>max_payload_mass</span><span class=p>)</span> <span class=k>as</span> <span class=n>cleared</span>
        <span class=k>from</span>
            <span class=n>pallets</span> <span class=n>p</span>
        <span class=k>inner</span> <span class=k>join</span>
            <span class=n>pallet_payload_mass</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>boxes</span><span class=p>)</span>
            <span class=k>on</span>
            <span class=n>ppm</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span>
    <span class=p>)</span> <span class=n>pc</span>
<span class=k>where</span>
    <span class=n>pc</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=s1>'...'</span><span class=p>;</span>
</code></pre></div></div>
<p>Which in turn expands into:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>select</span>
    <span class=n>pc</span><span class=p>.</span><span class=n>cleared</span>
<span class=k>from</span>
    <span class=p>(</span>
        <span class=k>select</span>
            <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>,</span>
            <span class=p>(</span><span class=n>ppm</span><span class=p>.</span><span class=n>payload_mass</span> <span class=o>&lt;=</span> <span class=n>p</span><span class=p>.</span><span class=n>max_payload_mass</span><span class=p>)</span> <span class=k>as</span> <span class=n>cleared</span>
        <span class=k>from</span>
            <span class=n>pallets</span> <span class=n>p</span>
        <span class=k>inner</span> <span class=k>join</span>
            <span class=p>(</span>
                <span class=k>select</span>
                    <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span><span class=p>,</span>
                    <span class=n>coalesce</span><span class=p>(</span><span class=k>sum</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>mass</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=k>as</span> <span class=n>payload_mass</span>
                <span class=k>from</span>
                    <span class=n>pallets</span> <span class=n>p</span>
                <span class=k>left</span> <span class=k>outer</span> <span class=k>join</span>
                    <span class=n>boxes</span> <span class=n>b</span> <span class=k>on</span> <span class=n>b</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span>
                <span class=k>group</span> <span class=k>by</span>
                    <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span>
            <span class=p>)</span> <span class=n>ppm</span>
            <span class=k>on</span>
            <span class=n>ppm</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=n>p</span><span class=p>.</span><span class=n>pallet_id</span>
    <span class=p>)</span> <span class=n>pc</span>
<span class=k>where</span>
    <span class=n>pc</span><span class=p>.</span><span class=n>pallet_id</span> <span class=o>=</span> <span class=s1>'...'</span><span class=p>;</span>
</code></pre></div></div>
<p>This is not satisfactory. It has the same problem of views: we’re doing the filtering at the end, and relying on the query planner to push the predicate down as far as it will go. Anecdotally, Postgres is more aggressive about optimizing subqueries than views, but relying on query planner arcana does not inspire confidence. We want to be able to write queries that expand into what a talented DBA would write by hand.</p>
<p>Can we do better? Yes. We can just do this:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>with</span> <span class=n>pallets</span> <span class=k>as</span> <span class=p>(</span>
    <span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>pallets</span> <span class=k>where</span> <span class=n>pallet_id</span> <span class=o>=</span> <span class=s1>'...'</span>
<span class=p>)</span>
<span class=k>select</span>
    <span class=n>cleared</span>
<span class=k>from</span>
    <span class=n>pallet_clearance</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>pallet_payload_mass</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>boxes</span><span class=p>));</span>
</code></pre></div></div>
<p>And that’s it. If we want to filter a table early, we just filter it early, and pass the result to the functor. The functor can be applied to any table that satisfies the interface, including CTEs or <code class="language-plaintext highlighter-rouge">select</code> expressions.</p>
<p>You can’t do this with native SQL, because SQL does not compose. The closest you could implement is copying the business logic query manually into a CTE, renaming the table references (and hoping you didn’t forget any), and now you have one more query duplicating business logic that has to be kept in sync with everything else.</p>
<p>Note, also, that you can’t do the above with views. That is, you can’t define a CTE that filters a table early, and then pass that CTE to a view.</p>
<h1 id=conclusion>Conclusion</h1>
<p>We could keep going, and implement the rest of the functors for the logic of the logistics system. But these examples are enough to prove that functors solve the biggest pain points of SQL. We can write queries that are fast, testable, and which can be understood through entirely local reasoning.</p>
<p>Could this be built? Yes. You could implement it as a compiler that takes a schema definition, and compiles functor-augmented SQL down to bare SQL by recursively macroexpanding the functors. And also does typechecking etc. The hardest part would be parsing and interpreting SQL syntax, which is a separate <a href=https://borretti.me/article/why-lisp-syntax-works#specific>problem</a>.</p>
<h1 id=app>Appendices</h1>
<p>Tangents, and brief sketches for extending the ideas in this post.</p>
<h2 id=generics>Apendix: Generics</h2>
<p>What if we want to factor out this into a functor:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>pallets</span> <span class=k>where</span> <span class=n>pallet_id</span> <span class=o>=</span> <span class=s1>'...'</span>
</code></pre></div></div>
<p>We can’t do this:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=n>functor</span> <span class=n>get_pallet_by_id</span><span class=p>(</span>
    <span class=n>p</span> <span class=k>table</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>),</span>
    <span class=n>id</span> <span class=n>uuid</span>
<span class=p>)</span> <span class=k>returns</span> <span class=o>???</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=o>*</span>
    <span class=k>from</span>
        <span class=n>p</span>
    <span class=k>where</span>
        <span class=n>pallet_id</span> <span class=o>=</span> <span class=n>id</span><span class=p>;</span>
</code></pre></div></div>
<p>Because what would we put as the return type? But we could do something like this:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=n>functor</span> <span class=n>get_pallet_by_id</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>(</span>
    <span class=n>p</span> <span class=k>table</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>A</span><span class=p>...),</span>
    <span class=n>id</span> <span class=n>uuid</span>
<span class=p>)</span> <span class=k>returns</span> <span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>A</span><span class=p>...)</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=o>*</span>
    <span class=k>from</span>
        <span class=n>p</span>
    <span class=k>where</span>
        <span class=n>pallet_id</span> <span class=o>=</span> <span class=n>id</span><span class=p>;</span>
</code></pre></div></div>
<p>Where <code class="language-plaintext highlighter-rouge">A</code> is a generic table type and the type <code class="language-plaintext highlighter-rouge">(pallet_id uuid, A...)</code> represents the set union between <code class="language-plaintext highlighter-rouge">A</code> and the type <code class="language-plaintext highlighter-rouge">(pallet_id uuid)</code>. So <code class="language-plaintext highlighter-rouge">get_pallet_by_id(pallets, '...')</code> has the return type:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=p>(</span><span class=n>pallet_id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>dry_mass</span> <span class=nb>decimal</span><span class=p>,</span> <span class=n>max_payload_mass</span> <span class=nb>decimal</span><span class=p>)</span>
</code></pre></div></div>
<p>And with this, we can rewrite:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>with</span> <span class=n>pallets</span> <span class=k>as</span> <span class=p>(</span>
    <span class=k>select</span> <span class=o>*</span> <span class=k>from</span> <span class=n>pallets</span> <span class=k>where</span> <span class=n>pallet_id</span> <span class=o>=</span> <span class=s1>'...'</span>
<span class=p>)</span>
<span class=k>select</span>
    <span class=n>cleared</span>
<span class=k>from</span>
    <span class=n>pallet_clearance</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>pallet_payload_mass</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>boxes</span><span class=p>));</span>
</code></pre></div></div>
<p>Like so:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>with</span> <span class=n>pallets</span> <span class=k>as</span> <span class=n>get_pallet_by_id</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=s1>'...'</span><span class=p>)</span>
<span class=k>select</span>
    <span class=n>cleared</span>
<span class=k>from</span>
    <span class=n>pallet_clearance</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>pallet_payload_mass</span><span class=p>(</span><span class=n>pallets</span><span class=p>,</span> <span class=n>boxes</span><span class=p>));</span>
</code></pre></div></div>
<p>With functors, SQL can be short, simple, and understandable, without sacrificing performance.</p>
<h2 id=general>Appendix: Generalizing Business Logic</h2>
<p>One aspect of the logistics platform example is that the business logic for pallets and containers is the same, but at different levels:</p>
<ul>
 <li>Both pallets and containers have a notion of a payload mass, which is the sum of the (wet) masses of their contents.</li>
 <li>Both have a notion of a maximum payload mass, and a boolean property that indicates being in excess of that mass.</li>
 <li>Both have a notion of a wet mass, which is the sum of their dry mass and the payload mass.</li>
</ul>
<p>We can implement functors in a way that is generic for both kinds of object, and use SQL renaming to map column names.</p>
<p>For example, this functor:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=n>functor</span> <span class=n>payload_mass</span><span class=p>(</span>
    <span class=n>a</span> <span class=k>table</span> <span class=p>(</span><span class=n>id</span> <span class=n>uuid</span><span class=p>),</span>
    <span class=n>b</span> <span class=k>table</span> <span class=p>(</span><span class=n>id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>mass</span> <span class=nb>decimal</span><span class=p>)</span>
<span class=p>)</span> <span class=k>returns</span> <span class=k>table</span> <span class=p>(</span><span class=n>id</span> <span class=n>uuid</span><span class=p>,</span> <span class=n>payload_mass</span> <span class=nb>decimal</span><span class=p>)</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=n>a</span><span class=p>.</span><span class=n>id</span><span class=p>,</span>
        <span class=n>coalesce</span><span class=p>(</span><span class=k>sum</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>mass</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=k>as</span> <span class=n>payload_mass</span>
    <span class=k>from</span>
        <span class=n>a</span>
    <span class=k>left</span> <span class=k>outer</span> <span class=k>join</span>
        <span class=n>b</span> <span class=k>on</span> <span class=n>b</span><span class=p>.</span><span class=n>id</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>id</span>
    <span class=k>group</span> <span class=k>by</span>
        <span class=n>a</span><span class=p>.</span><span class=n>id</span><span class=p>;</span>
</code></pre></div></div>
<p>Expresses the general concept of “map an object to the sum of the masses of its children”. This can work for pallets:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>payload_mass</span><span class=p>(</span>
    <span class=k>select</span> <span class=n>pallet_id</span> <span class=k>as</span> <span class=n>id</span> <span class=k>from</span> <span class=n>pallets</span><span class=p>,</span>
    <span class=k>select</span> <span class=n>pallet_id</span> <span class=k>as</span> <span class=n>id</span><span class=p>,</span> <span class=n>mass</span> <span class=k>from</span> <span class=n>boxes</span>
<span class=p>);</span>
</code></pre></div></div>
<p>And containers:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=n>payload_mass</span><span class=p>(</span>
    <span class=k>select</span> <span class=n>container_id</span> <span class=k>as</span> <span class=n>id</span> <span class=k>from</span> <span class=n>containers</span><span class=p>,</span>
    <span class=k>select</span> <span class=n>pallet_id</span> <span class=k>as</span> <span class=n>id</span><span class=p>,</span> <span class=n>mass</span> <span class=k>from</span> <span class=n>pallets_with_mass</span>
<span class=p>);</span>
</code></pre></div></div>
<p>Where <code class="language-plaintext highlighter-rouge">pallets_with_mass</code> is the result of joining <code class="language-plaintext highlighter-rouge">pallets</code> to the functor that calculates their mass.</p>
<p>You can also generalize this further by making the ID type generic, e.g.:</p>
<div class="language-sql highlighter-rouge"><div class=highlight><pre class=highlight><code><span class=k>create</span> <span class=n>functor</span> <span class=n>payload_mass</span><span class=o>&lt;</span><span class=n>ID</span><span class=p>:</span> <span class=n>Eq</span><span class=o>&gt;</span><span class=p>(</span>
    <span class=n>a</span> <span class=k>table</span> <span class=p>(</span><span class=n>id</span> <span class=n>ID</span><span class=p>),</span>
    <span class=n>b</span> <span class=k>table</span> <span class=p>(</span><span class=n>id</span> <span class=n>ID</span><span class=p>,</span> <span class=n>mass</span> <span class=nb>decimal</span><span class=p>)</span>
<span class=p>)</span> <span class=k>returns</span> <span class=k>table</span> <span class=p>(</span><span class=n>id</span> <span class=n>ID</span><span class=p>,</span> <span class=n>payload_mass</span> <span class=nb>decimal</span><span class=p>)</span> <span class=k>as</span>
    <span class=k>select</span>
        <span class=n>a</span><span class=p>.</span><span class=n>id</span><span class=p>,</span>
        <span class=n>coalesce</span><span class=p>(</span><span class=k>sum</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>mass</span><span class=p>),</span> <span class=mi>0</span><span class=p>)</span> <span class=k>as</span> <span class=n>payload_mass</span>
    <span class=k>from</span>
        <span class=n>a</span>
    <span class=k>left</span> <span class=k>outer</span> <span class=k>join</span>
        <span class=n>b</span> <span class=k>on</span> <span class=n>b</span><span class=p>.</span><span class=n>id</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>id</span>
    <span class=k>group</span> <span class=k>by</span>
        <span class=n>a</span><span class=p>.</span><span class=n>id</span><span class=p>;</span>
</code></pre></div></div>
<h2 id=naming>Appendix: Naming</h2>
<p>Why functor? Well, the alternatives aren’t very good:</p>
<ul>
 <li>“Function” is confusing because SQL already has <a href=https://www.postgresql.org/docs/current/functions.html>functions</a>.</li>
 <li>“Parameterized query” takes too long to say and is confusing because SQL queries can take scalar <a href=https://www.postgresql.org/docs/current/sql-prepare.html>parameters</a>.</li>
 <li>“Generic query” is too vague and also too many words.</li>
 <li>“Query component/transformer/operator” is too wordy and too vague.</li>
 <li>“Query template” sounds like C++, and de-emphasizes the static type-checking aspect.</li>
 <li>“Macro” sounds too untyped and stringly typed. <a href=https://docs.getdbt.com/docs/build/jinja-macros>dbt</a> has macros, and they are stringly typed.</li>
</ul>
<p>“Functor” is one word and conveys the notion that it’s happening one level up from queries.</p>
<h2 id=global>Appendix: Global Variables</h2>
<p>Functors can specify the tables they depend on as parameters. A more interesting restriction is if functors can <em>only</em> query from tables explicitly listed as parameters.</p>
<p>Why would this be useful? Because SQL tables are <em>global variables</em>. By vanishing global variables, we automatically make every query fully testable.</p>
<h1 id=footnotes>Footnotes</h1>
<div class=footnotes role=doc-endnotes>
 <ol>
 <li id=fn:perf role=doc-endnote>
 <p>It’s strange to me how bad query planners are, given how limited SQL is in terms of expressivity. SQL isn’t <em>usefully</em> Turing complete, but it’s Turing complete enough that the query planner has to be extremely conservative to preserve soundness. Which is the worst of both worlds.&nbsp;<a href=#fnref:perf class=reversefootnote role=doc-backlink>↩</a></p>
 </li>
 <li id=fn:syn role=doc-endnote>
 <p>I tried to keep the syntax in line with the SQL style, which means it is hideously verbose.&nbsp;<a href=#fnref:syn class=reversefootnote role=doc-backlink>↩</a></p>
 </li>
 <li id=fn:null role=doc-endnote>
 <p>For brevity, I’m omitting <code class="language-plaintext highlighter-rouge">not null</code> declarations.&nbsp;<a href=#fnref:null class=reversefootnote role=doc-backlink>↩</a></p>
 </li>
 </ol>
</div>
 </article>
</div>
</main>
 <nav class=bottom-nav>
 <ul>
 <li>
 <a href=https://borretti.me/>Home</a>
 </li>
 <li>
 <span class=sep>—</span>
 </li>
 <li>
 <a href=https://borretti.me/about>About</a>
 </li>
 <li>
 <span class=sep>—</span>
 </li>
 <li>
 <a href=https://borretti.me/portfolio>Portfolio</a>
 </li>
 <li>
 <span class=sep>—</span>
 </li>
 <li>
 <a href=https://borretti.me/article>Articles</a>
 </li>
 <li>
 <span class=sep>—</span>
 </li>
 <li>
 <a href=https://borretti.me/fiction>Fiction</a>
 </li>
 <li>
 <span class=sep>—</span>
 </li>
 <li>
 <a href=https://borretti.me/feed.xml>RSS</a>
 </li>
 </ul>
 </nav>
 <footer>
 <div class=copy>
 © 2014 – 2025 Fernando Borretti
 </div>
 </footer>
</div>
 
 
 
 
 
<deepl-input-controller><template shadowrootmode=open><div dir=ltr><div class="dl-input-translation-container svelte-95aucy"><div></div></div></div></template></deepl-input-controller><script data-template-shadow-root>(()=>{document.currentScript.remove();processNode(document);function processNode(node){node.querySelectorAll("template[shadowrootmode]").forEach(element=>{let shadowRoot = element.parentElement.shadowRoot;if (!shadowRoot) {try {shadowRoot=element.parentElement.attachShadow({mode:element.getAttribute("shadowrootmode"),delegatesFocus:element.getAttribute("shadowrootdelegatesfocus")!=null,clonable:element.getAttribute("shadowrootclonable")!=null,serializable:element.getAttribute("shadowrootserializable")!=null});shadowRoot.innerHTML=element.innerHTML;element.remove()} catch (error) {} if (shadowRoot) {processNode(shadowRoot)}}})}})()</script>